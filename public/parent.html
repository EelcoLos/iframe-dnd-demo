<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Drag & Drop Between iFrames - Parent</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 20px;
    }
    
    h1 {
      color: white;
      text-align: center;
      margin-bottom: 10px;
      font-size: 2em;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
    }
    
    .demo-selector {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    .demo-button {
      background: white;
      color: #5a67d8;
      border: 2px solid white;
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    .demo-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    
    .demo-button.active {
      background: #5a67d8;
      color: white;
      border-color: #5a67d8;
    }
    
    .container {
      display: flex;
      gap: 20px;
      flex: 1;
      min-height: 0;
    }
    
    .iframe-wrapper {
      flex: 1;
      background: white;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    
    .iframe-header {
      background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
      color: white;
      padding: 15px;
      font-weight: 600;
      font-size: 1.1em;
      text-align: center;
      border-bottom: 3px solid rgba(255,255,255,0.2);
    }
    
    iframe {
      flex: 1;
      border: none;
      width: 100%;
      display: block;
    }
    
    .drag-preview {
      position: fixed;
      pointer-events: none;
      background: #4f46e5;
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 8px 16px rgba(0,0,0,0.3);
      font-weight: 600;
      font-size: 14px;
      z-index: 10000;
      opacity: 0.9;
      transform: translate(-50%, -50%);
    }
  </style>
</head>
<body>
  <h1>ðŸŽ¯ Drag & Drop Between iFrames Demo</h1>
  <div class="demo-selector">
    <button class="demo-button active" data-demo="basic">Basic Items Demo</button>
    <button class="demo-button" data-demo="table">Table Rows Demo</button>
  </div>
  <div class="container">
    <div class="iframe-wrapper">
      <div class="iframe-header" id="header-a">Frame A - Draggable Items</div>
      <iframe id="frame-a" src="frame-a.html"></iframe>
    </div>
    <div class="iframe-wrapper">
      <div class="iframe-header" id="header-b">Frame B - Drop Zones</div>
      <iframe id="frame-b" src="frame-b.html"></iframe>
    </div>
  </div>

  <script type="module">
    let isDragging = false;
    let dragData = null;
    let dragPreview = null;
    let frameA = null;
    let frameB = null;
    let clipboardData = null;

    /**
     * Check if a pointer position is over a specific iframe
     * Uses both elementFromPoint and coordinate bounds for reliable detection
     */
    function isOverFrame(elementUnder, frameElement, clientX, clientY) {
      if (!frameElement) return false;
      
      // Direct element match
      if (elementUnder === frameElement) return true;
      
      // Coordinate-based fallback for Firefox and other browsers
      // where elementFromPoint might not return the iframe element
      const rect = frameElement.getBoundingClientRect();
      return clientX >= rect.left && clientX <= rect.right && 
             clientY >= rect.top && clientY <= rect.bottom;
    }

    // Wait for iframes to load
    window.addEventListener('load', () => {
      frameA = document.getElementById('frame-a');
      frameB = document.getElementById('frame-b');

      // Set up demo switching
      setupDemoSwitcher();

      // Listen for messages from frames
      window.addEventListener('message', (event) => {
        // Validate that the message is from one of our iframes
        // Check both event.source and event.origin for security
        const isFromFrameA = event.source === frameA?.contentWindow;
        const isFromFrameB = event.source === frameB?.contentWindow;
        const isSameOrigin = event.origin === window.location.origin;
        
        if ((!isFromFrameA && !isFromFrameB) || !isSameOrigin) {
          // Ignore messages from unknown sources or different origins
          return;
        }

        if (event.data.type === 'dragStart') {
          startDrag(event.data);
        } else if (event.data.type === 'dragEnd') {
          handleIframeDragEnd(event.data);
        } else if (event.data.type === 'dragMove') {
          // Handle drag move from iframes
          handleIframeDragMove(event.data);
        } else if (event.data.type === 'dropSuccess') {
          // Handle successful drop - remove item from source
          // Determine which frame sent the message
          const targetFrame = isFromFrameA ? 'frame-a' : 'frame-b';
          handleDropSuccess(event.data.dragData, targetFrame);
        } else if (event.data.type === 'dropFailed') {
          // Handle failed drop - do not remove item from source
          handleDropFailed(event.data.dragData);
        } else if (event.data.type === 'rowCopied') {
          // Relay copied row data to all frames
          handleRowCopied(event.data);
        } else if (event.data.type === 'itemCopied') {
          // Store copied item data in clipboard
          clipboardData = event.data.itemData;
        } else if (event.data.type === 'requestPaste') {
          // Handle paste request from a frame
          handlePasteRequest(event.data.target);
        } else if (event.data.type === 'pasteSuccess') {
          // Handle successful paste - remove item from source if it was a move
          if (clipboardData && clipboardData.source === 'frame-a') {
            frameA.contentWindow.postMessage({
              type: 'removeItem',
              id: clipboardData.id
            }, '*');
            clipboardData = null; // Clear clipboard after move
          }
        }
      });

      // Set up pointer event listeners on the parent
      document.addEventListener('pointermove', handlePointerMove);
      document.addEventListener('pointerup', handlePointerUp);
    });

    function handlePasteRequest(target) {
      if (!clipboardData) return;
      
      const targetFrame = target === 'frame-a' ? frameA : frameB;
      
      try {
        targetFrame.contentWindow.postMessage({
          type: 'pasteItem',
          itemData: clipboardData
        }, '*');
      } catch (err) {
        console.error('Failed to send paste message:', err);
      }
    }

    function setupDemoSwitcher() {
      const buttons = document.querySelectorAll('.demo-button');
      buttons.forEach(button => {
        button.addEventListener('click', () => {
          const demo = button.dataset.demo;
          switchDemo(demo);
          
          // Update active state
          buttons.forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');
        });
      });
    }

    function switchDemo(demo) {
      const headerA = document.getElementById('header-a');
      const headerB = document.getElementById('header-b');
      
      if (demo === 'table') {
        frameA.src = 'frame-a-table.html';
        frameB.src = 'frame-b-table.html';
        headerA.textContent = 'Frame A - Construction Calculation';
        headerB.textContent = 'Frame B - Candidate Rows';
      } else {
        frameA.src = 'frame-a.html';
        frameB.src = 'frame-b.html';
        headerA.textContent = 'Frame A - Draggable Items';
        headerB.textContent = 'Frame B - Drop Zones';
      }
    }

    function handleRowCopied(data) {
      // Relay copied row data to both frames so they can paste
      console.log('Parent relaying rowCopied:', data.rowData?.description);
      try {
        if (frameA && frameA.contentWindow) {
          frameA.contentWindow.postMessage({
            type: 'rowCopied',
            rowData: data.rowData
          }, '*');
          console.log('Sent rowCopied to Frame A');
        } else {
          console.warn('Frame A not ready for postMessage');
        }
        if (frameB && frameB.contentWindow) {
          frameB.contentWindow.postMessage({
            type: 'rowCopied',
            rowData: data.rowData
          }, '*');
          console.log('Sent rowCopied to Frame B');
        } else {
          console.warn('Frame B not ready for postMessage');
        }
      } catch (err) {
        console.error('Failed to relay copied row data:', err);
      }
    }

    function startDrag(data) {
      isDragging = true;
      dragData = data;

      // Create drag preview
      dragPreview = document.createElement('div');
      dragPreview.className = 'drag-preview';
      dragPreview.textContent = data.text;
      document.body.appendChild(dragPreview);
    }

    function handleIframeDragMove(data) {
      if (!isDragging || !dragPreview) return;

      // The iframe sends us coordinates relative to its own viewport
      // We need to convert them to parent coordinates
      const sourceFrame = data.source === 'frame-a' ? frameA : frameB;
      const frameRect = sourceFrame.getBoundingClientRect();
      
      const parentX = frameRect.left + data.clientX;
      const parentY = frameRect.top + data.clientY;

      // Update drag preview position
      dragPreview.style.left = parentX + 'px';
      dragPreview.style.top = parentY + 'px';

      // Check which frame we're over
      dragPreview.style.display = 'none';
      const elementUnder = document.elementFromPoint(parentX, parentY);
      dragPreview.style.display = '';

      updateFrameHover(elementUnder, parentX, parentY);
    }

    function handleIframeDragEnd(data) {
      if (!isDragging || !dragPreview) return;

      // The iframe sends us where the pointer was released
      // Convert to parent coordinates
      const sourceFrame = data.source === 'frame-a' ? frameA : frameB;
      const frameRect = sourceFrame.getBoundingClientRect();
      
      const parentX = frameRect.left + data.clientX;
      const parentY = frameRect.top + data.clientY;

      // Hide preview to check element under pointer
      dragPreview.style.display = 'none';
      const elementUnder = document.elementFromPoint(parentX, parentY);
      dragPreview.style.display = '';

      let dropped = false;

      // Check if we're over each frame using the helper function
      const overFrameA = isOverFrame(elementUnder, frameA, parentX, parentY);
      const overFrameB = isOverFrame(elementUnder, frameB, parentX, parentY);

      // Check if we're dropping on frame-a
      if (overFrameA && dragData.source !== 'frame-a' && dragData.source !== 'frame-a-table') {
        const frameARect = frameA.getBoundingClientRect();
        const relativeX = parentX - frameARect.left;
        const relativeY = parentY - frameARect.top;

        try {
          frameA.contentWindow.postMessage({
            type: 'parentDrop',
            x: relativeX,
            y: relativeY,
            dragData: dragData
          }, '*');
          dropped = true;
          

          // Remove item from source frame (Frame B) - but not for table demo (copy semantics)
          if (dragData.source === 'frame-b') {
            frameB.contentWindow.postMessage({
              type: 'removeItem',
              id: dragData.id
            }, '*');
          }
          // For frame-b-table, we keep the item (copy semantics)
        } catch (err) {
          console.error('Failed to send drop message to frame-a:', err);
        }
      }
      // Check if we're dropping on frame-b
      else if (overFrameB) {
        const frameBRect = frameB.getBoundingClientRect();
        const relativeX = parentX - frameBRect.left;
        const relativeY = parentY - frameBRect.top;

        try {
          frameB.contentWindow.postMessage({
            type: 'parentDrop',
            x: relativeX,
            y: relativeY,
            dragData: dragData
          }, '*');
          dropped = true;
          
        } catch (err) {
          console.error('Failed to send drop message to frame-b:', err);
        }
      }

      endDrag();
    }

    function handlePointerMove(e) {
      if (!isDragging || !dragPreview) return;

      // Update drag preview position
      dragPreview.style.left = e.clientX + 'px';
      dragPreview.style.top = e.clientY + 'px';

      // Temporarily hide the preview to use elementFromPoint
      dragPreview.style.display = 'none';
      const elementUnder = document.elementFromPoint(e.clientX, e.clientY);
      dragPreview.style.display = '';

      updateFrameHover(elementUnder, e.clientX, e.clientY);
    }

    function updateFrameHover(elementUnder, clientX, clientY) {
      // Determine which frame we're over using the helper function
      const overFrameA = isOverFrame(elementUnder, frameA, clientX, clientY);
      const overFrameB = isOverFrame(elementUnder, frameB, clientX, clientY);

      // Handle Frame A
      if (overFrameA && dragData.source !== 'frame-a' && dragData.source !== 'frame-a-table') {
        // Dragging from Frame B to Frame A
        const frameARect = frameA.getBoundingClientRect();
        const relativeX = clientX - frameARect.left;
        const relativeY = clientY - frameARect.top;

        try {
          frameA.contentWindow.postMessage({
            type: 'parentDragMove',
            x: relativeX,
            y: relativeY,
            dragData: dragData
          }, '*');
        } catch (err) {
          console.error('Failed to send message to frame-a:', err);
        }

        // Send drag leave to Frame B
        try {
          frameB.contentWindow.postMessage({ type: 'parentDragLeave' }, '*');
        } catch (err) {
          // Ignore
        }
      } 
      // Handle Frame B
      else if (overFrameB) {
        // Dragging to Frame B (from either frame)
        const frameBRect = frameB.getBoundingClientRect();
        const relativeX = clientX - frameBRect.left;
        const relativeY = clientY - frameBRect.top;

        try {
          frameB.contentWindow.postMessage({
            type: 'parentDragMove',
            x: relativeX,
            y: relativeY,
            dragData: dragData
          }, '*');
        } catch (err) {
          console.error('Failed to send message to frame-b:', err);
        }

        // Send drag leave to Frame A if dragging from B or B-table
        if (dragData.source === 'frame-b' || dragData.source === 'frame-b-table') {
          try {
            frameA.contentWindow.postMessage({ type: 'parentDragLeave' }, '*');
          } catch (err) {
            // Ignore
          }
        }
      } 
      // Not over any frame
      else {
        // Send drag leave to both frames
        try {
          frameA.contentWindow.postMessage({ type: 'parentDragLeave' }, '*');
          frameB.contentWindow.postMessage({ type: 'parentDragLeave' }, '*');
        } catch (err) {
          // Ignore
        }
      }
    }

    function handlePointerUp(e) {
      if (!isDragging) return;

      // Hide preview to check element under pointer
      if (dragPreview) {
        dragPreview.style.display = 'none';
      }
      
      const elementUnder = document.elementFromPoint(e.clientX, e.clientY);
      let dropped = false;

      // Check if we're over each frame using the helper function
      const overFrameA = isOverFrame(elementUnder, frameA, e.clientX, e.clientY);
      const overFrameB = isOverFrame(elementUnder, frameB, e.clientX, e.clientY);

      // Check if we're dropping on frame-a
      if (overFrameA && dragData.source !== 'frame-a' && dragData.source !== 'frame-a-table') {
        const frameARect = frameA.getBoundingClientRect();
        const relativeX = e.clientX - frameARect.left;
        const relativeY = e.clientY - frameARect.top;

        try {
          frameA.contentWindow.postMessage({
            type: 'parentDrop',
            x: relativeX,
            y: relativeY,
            dragData: dragData
          }, '*');
          dropped = true;
          

          // Remove item from source frame (Frame B) - but not for table demo (copy semantics)
          if (dragData.source === 'frame-b') {
            frameB.contentWindow.postMessage({
              type: 'removeItem',
              id: dragData.id
            }, '*');
          }
          // For frame-b-table, we keep the item (copy semantics)
        } catch (err) {
          console.error('Failed to send drop message to frame-a:', err);
        }
      }
      // Check if we're dropping on frame-b
      else if (overFrameB) {
        const frameBRect = frameB.getBoundingClientRect();
        const relativeX = e.clientX - frameBRect.left;
        const relativeY = e.clientY - frameBRect.top;

        try {
          frameB.contentWindow.postMessage({
            type: 'parentDrop',
            x: relativeX,
            y: relativeY,
            dragData: dragData
          }, '*');
          dropped = true;
          
        } catch (err) {
          console.error('Failed to send drop message to frame-b:', err);
        }
      }

      endDrag();
    }

    function endDrag() {
      isDragging = false;
      dragData = null;

      if (dragPreview) {
        dragPreview.remove();
        dragPreview = null;
      }

      // Send drag leave to both frames to clear any hover states
      try {
        if (frameA && frameA.contentWindow) {
          frameA.contentWindow.postMessage({
            type: 'parentDragLeave'
          }, '*');
        }
        if (frameB && frameB.contentWindow) {
          frameB.contentWindow.postMessage({
            type: 'parentDragLeave'
          }, '*');
        }
      } catch (err) {
        // Ignore
      }
    }
    
    function handleDropSuccess(dragData, targetFrame) {
      // Only remove item from source if this is a cross-frame drop
      // Same-frame move example: dragData.source='frame-b' && targetFrame='frame-b'
      // (moving between zones within Frame B - already handled locally)
      // Cross-frame drop example: dragData.source='frame-a' && targetFrame='frame-b'
      // (moving from Frame A to Frame B - need to remove from source)
      if (dragData.source !== targetFrame) {
        if (dragData.source === 'frame-a') {
          frameA.contentWindow.postMessage({
            type: 'removeItem',
            id: dragData.id
          }, '*');
        } else if (dragData.source === 'frame-b') {
          frameB.contentWindow.postMessage({
            type: 'removeItem',
            id: dragData.id
          }, '*');
        }
      }
    }
    
    function handleDropFailed(dragData) {
      // Do nothing - item stays in source frame
      console.log('Drop failed - item will remain in source frame');
    }
  </script>
</body>
</html>
