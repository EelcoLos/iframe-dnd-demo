<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Drop Zones</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      padding: 20px;
      background: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
      min-height: 100vh;
    }

    h2 {
      color: #4f46e5;
      margin-bottom: 20px;
      font-size: 1.5em;
    }

    .drop-zones {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .drop-zone {
      background: white;
      border: 3px dashed #cbd5e1;
      border-radius: 12px;
      padding: 20px;
      min-height: 150px;
      transition: all 0.2s ease;
    }

    .drop-zone.hover {
      background: #e0e7ff;
      border-color: #4f46e5;
      border-style: solid;
      box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
      transform: scale(1.02);
    }

    .zone-header {
      font-weight: 600;
      font-size: 1.2em;
      margin-bottom: 15px;
      color: #334155;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .zone-items {
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 80px;
    }

    .dropped-item {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      padding: 15px 20px;
      border-radius: 8px;
      font-weight: 500;
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
      animation: dropIn 0.3s ease;
      cursor: move;
      user-select: none;
      touch-action: none;
    }

    .dropped-item.dragging {
      opacity: 0.5;
    }

    @keyframes dropIn {
      from {
        opacity: 0;
        transform: translateY(-20px) scale(0.9);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .hint {
      text-align: center;
      color: #94a3b8;
      font-size: 0.9em;
      margin-top: 20px;
    }

    .empty-state {
      text-align: center;
      color: #94a3b8;
      font-style: italic;
      padding: 20px;
    }
  </style>
</head>
<body>
  <h2>üéØ Drop Zones</h2>
  <div class="drop-zones">
    <div class="drop-zone" data-zone="todo">
      <div class="zone-header">üìã To Do</div>
      <div class="zone-items">
        <div class="empty-state">Drop items here</div>
      </div>
    </div>

    <div class="drop-zone" data-zone="in-progress">
      <div class="zone-header">üöÄ In Progress</div>
      <div class="zone-items">
        <div class="empty-state">Drop items here</div>
      </div>
    </div>

    <div class="drop-zone" data-zone="done">
      <div class="zone-header">‚úÖ Done</div>
      <div class="zone-items">
        <div class="empty-state">Drop items here</div>
      </div>
    </div>
  </div>
  <div class="hint">‚Üê Drag items from the Draggable Items window</div>

  <script type="module">
    import { BroadcastCommunicationManager } from './broadcast-communication.js';

    const windowId = 'frame-b';
    const broadcast = new BroadcastCommunicationManager({ windowId });
    broadcast.initialize();

    const dropZones = document.querySelectorAll('.drop-zone');
    let currentHoveredZone = null;
    let isDragActive = false;
    let draggedItemElement = null;
    let dragStartPos = { x: 0, y: 0 };
    let currentDragData = null;
    let isMouseOverWindow = false;
    const DRAG_THRESHOLD = 5;

    // Track if mouse is over this window
    document.addEventListener('mouseenter', () => {
      isMouseOverWindow = true;
    });

    document.addEventListener('mouseleave', () => {
      isMouseOverWindow = false;
      clearHoverStates();
    });

    // Listen for drag start
    broadcast.on('dragStart', (data) => {
      isDragActive = true;
      currentDragData = data;
      console.log('Drag started from another window:', data);
      
      // Show visual feedback that drag is active
      document.body.style.cursor = 'grabbing';
    });

    // Listen for drag end
    broadcast.on('dragEnd', (data) => {
      if (!isDragActive) return;
      
      console.log('Drag ended, mouse over window:', isMouseOverWindow);
      
      // If mouse was over this window and over a zone, handle the drop
      if (isMouseOverWindow && currentHoveredZone && currentDragData) {
        addItemToZone(currentHoveredZone, currentDragData);
        
        // Notify that item was dropped successfully
        broadcast.broadcast('removeItem', {
          id: currentDragData.id
        });
      }
      
      isDragActive = false;
      currentDragData = null;
      document.body.style.cursor = '';
      clearHoverStates();
    });

    function clearHoverStates() {
      dropZones.forEach(zone => zone.classList.remove('hover'));
      currentHoveredZone = null;
    }

    // Add hover detection for drop zones
    dropZones.forEach(zone => {
      zone.addEventListener('mouseenter', (e) => {
        if (isDragActive && currentDragData) {
          currentHoveredZone = zone;
          zone.classList.add('hover');
          console.log('Hovering over zone:', zone.dataset.zone);
        }
      });
      
      zone.addEventListener('mouseleave', (e) => {
        zone.classList.remove('hover');
        if (currentHoveredZone === zone) {
          currentHoveredZone = null;
        }
      });
    });

    function addItemToZone(zone, dragData) {
      const zoneItems = zone.querySelector('.zone-items');
      
      // Remove empty state if present
      const emptyState = zoneItems.querySelector('.empty-state');
      if (emptyState) {
        emptyState.remove();
      }
      
      // Create dropped item
      const item = document.createElement('div');
      item.className = 'dropped-item';
      item.dataset.id = dragData.id;
      item.textContent = dragData.text;
      
      zoneItems.appendChild(item);
      
      // Make it draggable back out
      setupDraggableItem(item);
      
      console.log('Item added to zone:', dragData.text);
    }

    // Setup dragging for items in drop zones
    function setupDraggableItem(element) {
      element.addEventListener('pointerdown', handleItemPointerDown);
    }

    function handleItemPointerDown(e) {
      if (e.button !== 0) return;
      
      draggedItemElement = e.currentTarget;
      dragStartPos = { x: e.clientX, y: e.clientY };
      
      document.addEventListener('pointermove', handleItemPointerMove);
      document.addEventListener('pointerup', handleItemPointerUp);
      
      draggedItemElement.setPointerCapture(e.pointerId);
    }

    function handleItemPointerMove(e) {
      if (!draggedItemElement) return;
      
      const dx = e.clientX - dragStartPos.x;
      const dy = e.clientY - dragStartPos.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (!isDragActive && distance > DRAG_THRESHOLD) {
        startItemDrag(e);
      }
    }

    function handleItemPointerUp(e) {
      if (isDragActive) {
        endItemDrag(e);
      }
      
      document.removeEventListener('pointermove', handleItemPointerMove);
      document.removeEventListener('pointerup', handleItemPointerUp);
      
      if (draggedItemElement) {
        draggedItemElement.releasePointerCapture(e.pointerId);
        draggedItemElement = null;
      }
    }

    function startItemDrag(e) {
      isDragActive = true;
      draggedItemElement.classList.add('dragging');
      
      const dragData = {
        text: draggedItemElement.textContent.trim(),
        id: draggedItemElement.dataset.id,
        source: windowId
      };
      
      currentDragData = dragData;
      
      broadcast.broadcast('dragStart', dragData);
    }

    function endItemDrag(e) {
      broadcast.broadcast('dragEnd', {
        ...currentDragData,
        clientX: e.clientX,
        clientY: e.clientY,
        screenX: e.screenX,
        screenY: e.screenY
      });
      
      if (draggedItemElement) {
        draggedItemElement.classList.remove('dragging');
      }
      
      isDragActive = false;
      currentDragData = null;
    }

    // Listen for parent drop messages (for receiving items)
    broadcast.on('parentDrop', (data) => {
      if (!data.dragData) return;
      
      // Find which zone should receive this
      // This would need coordinate translation in a real implementation
      // For now, we'll default to the first zone
      const targetZone = dropZones[0];
      addItemToZone(targetZone, data.dragData);
    });

    // Initialize existing items as draggable
    document.querySelectorAll('.dropped-item').forEach(setupDraggableItem);
  </script>
</body>
</html>
